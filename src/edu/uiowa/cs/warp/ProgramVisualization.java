package edu.uiowa.cs.warp;

/**
 * Builds a visualization of the Warp program. The program is sometimes called a
 * scheduled because it defines the order in which flows transmit their messages
 * through the sensor network. The display graph is created with GraphStream.
 * 
 * @author sgoddard
 * @version 2.0 Fall 2025
 * 
 */
public class ProgramVisualization extends Visualization {
<<<<<<< HEAD

	/**
	 * Indicates the type of source file being visualized which is a domain specific language (dsl)
	 */
	private static final String SOURCE_SUFFIX = ".dsl"; 
	/**
	 * The schedule table of the current program
	 */
	private ProgramSchedule sourceCode; 
	/**
	 * The WARP program model being visualized
	 */
	private Program program; 
	/**
	 * True if all options meet their deadlines, false otherwise
	 */
	private Boolean deadlinesMet; 
	/**
	 * Runtime options that control visualization behavior
	 */
	private Options warpOptions; 

	/**
	 * Constructs a new visualization for the given WARP system.
	 * 
	 * @param warp the WARP system containing the program, schedule, deadlines, and options
	 */
	ProgramVisualization(WarpInterface warp) {
		super(warp, SOURCE_SUFFIX);
		this.program = warp.getProgram();
		this.sourceCode = program.getSchedule();
		this.deadlinesMet = warp.deadlinesMet();
		this.warpOptions = warp.getOptions();
	}
=======
/**
 * File suffix for the program source file representation (.dsl).
 * This is used to indicate the source format of WARP programs.
 */
  private static final String SOURCE_SUFFIX = ".dsl";
  /**
   * The program schedule (i.e., table of operations per node and time slot)
   * generated by the WARP system.
   */
  private ProgramSchedule sourceCode;
  /**
   * The WARP program being visualized. Contains scheduler information,
   * reliability parameters, channel usage, and fault model details.
   */
  private Program program;
  /**
   * Flag indicating whether all flows in the WARP program meet
   * their specified deadlines.
   */
  private Boolean deadlinesMet;
  /**
   * User-specified options for running WARP (e.g., scheduler choice,
   * visualization settings, verbosity).
   */
  private Options warpOptions;
/**
 * Constructs a {@code ProgramVisualization} object for a given WARP system.
 * Initializes the program, schedule, deadline status, and options
 * for visualization.
 * 
 * @param warp the WARP system instance containing program and workload details
 */
  ProgramVisualization(WarpInterface warp) {
    super(warp, SOURCE_SUFFIX);
    this.program = warp.getProgram();
    this.sourceCode = program.getSchedule();
    this.deadlinesMet = warp.deadlinesMet();
    this.warpOptions = warp.getOptions();
  }
>>>>>>> branch 'HW5' of https://research-git.uiowa.edu/smukunza/cs2820-smukunza

<<<<<<< HEAD
	/**
	 * Builds and returns the GUI window that displays the program schedule.
	 * 
	 * @return a GuiWindow configured with headers, columns, and data
	 */
	@Override
	protected GuiWindow displayVisualization() {
		return new GuiWindow(warpOptions, createTitle(), createColumnHeader(), createVisualizationData());
	}
=======
  /**
   * Creates and displays the visualization window for the WARP program.
   * The window includes a title, a column header, and a data table.
   * 
   * @return a {@link GuiWindow} that displays the program visualization
   */
  @Override
  protected GuiWindow displayVisualization() {
    return new GuiWindow(warpOptions, createTitle(), createColumnHeader(), createVisualizationData());
  }
  
  /**
   * Creates the header section of the visualization, which provides
   * metadata about the program such as scheduler name, reliability parameters,
   * and number of channels.
   * 
   * @return a {@link Description} containing header information
   */
>>>>>>> branch 'HW5' of https://research-git.uiowa.edu/smukunza/cs2820-smukunza

	/**
	 * Creates the header section of the visualization
	 * 
	 * @return a Description object containing the header information
	 */
	@Override
	protected Description createHeader() {
		Description header = new Description();

		header.add(createTitle());
		header.add(String.format("Scheduler Name: %s\n", program.getSchedulerName()));

<<<<<<< HEAD
		/*
		 * The following parameters are output based on a special schedule or the fault
		 * model
		 */
		if (program.getNumFaults() > 0) { // only specify when deterministic fault model is assumed
			header.add(String.format("numFaults: %d\n", program.getNumFaults()));
		}
		header.add(String.format("M: %s\n", String.valueOf(program.getMinPacketReceptionRate())));
		header.add(String.format("E2E: %s\n", String.valueOf(program.getE2E())));
		header.add(String.format("nChannels: %d\n", program.getNumChannels()));
		return header;
	}
=======
    /* The following parameters are output based on a special schedule or the fault model */
    if (program.getNumFaults() > 0) { // only specify when deterministic fault model is assumed
      header.add(String.format("numFaults: %d\n", program.getNumFaults()));
    }
    header.add(String.format("M: %s\n", String.valueOf(program.getMinPacketReceptionRate())));
    header.add(String.format("E2E: %s\n", String.valueOf(program.getE2E())));
    header.add(String.format("nChannels: %d\n", program.getNumChannels()));
    return header;
  }
  
  /**
   * Creates the footer section of the visualization, which includes
   * a summary of deadline satisfaction. If deadlines are not met,
   * a warning message is included.
   * 
   * @return a {@link Description} containing footer information
   */
>>>>>>> branch 'HW5' of https://research-git.uiowa.edu/smukunza/cs2820-smukunza

	/**
	 * Creates the footer section of the visualization.
	 * 
	 * @return a Description object containing the footer information
	 */
	@Override
	protected Description createFooter() {
		Description footer = new Description();
		String deadlineMsg = null;

<<<<<<< HEAD
		if (deadlinesMet) {
			deadlineMsg = "All flows meet their deadlines\n";
		} else {
			deadlineMsg = "WARNING: NOT all flows meet their deadlines. See deadline analysis report.\n";
		}
		footer.add(String.format("// %s", deadlineMsg));
		return footer;
	}
=======
    if (deadlinesMet) {
      deadlineMsg = "All flows meet their deadlines\n";
    } else {
      deadlineMsg = "WARNING: NOT all flows meet their deadlines. See deadline analysis report.\n";
    }
    footer.add(String.format("// %s", deadlineMsg));
    return footer;
  }
  
  /**
   * Creates the column header row for the visualization table.
   * The first column represents the time slot, followed by one
   * column for each node in the workload (ordered alphabetically).
   * 
   * @return an array of strings representing column names
   */
>>>>>>> branch 'HW5' of https://research-git.uiowa.edu/smukunza/cs2820-smukunza

	/**
	 * Creates the column headers for the schedule table.
	 * 
	 * @return an array of column header strings 
	 */
	@Override
	protected String[] createColumnHeader() {
		var orderedNodes = program.toWorkLoad().getNodeNamesOrderedAlphabetically();
		String[] columnNames = new String[orderedNodes.length + 1];
		columnNames[0] = "Time Slot"; // add the Time Slot column header first
		/* loop through the node names, adding each to the header */
		for (int i = 0; i < orderedNodes.length; i++) {
			columnNames[i + 1] = orderedNodes[i];
		}
		return columnNames;
	}

<<<<<<< HEAD
	/**
	 * Builds the 2D string table that represents the program schedule.
	 * 
	 * @return a 2D string array representing the schedule table
	 */
	@Override
	protected String[][] createVisualizationData() {
		if (visualizationData == null) {
			int numRows = sourceCode.getNumRows();
			int numColumns = sourceCode.getNumColumns();
			visualizationData = new String[numRows][numColumns + 1];
=======
  @Override
  protected String[] createColumnHeader() {
    var orderedNodes = program.toWorkLoad().getNodeNamesOrderedAlphabetically();
    String[] columnNames = new String[orderedNodes.length + 1];
    columnNames[0] = "Time Slot"; // add the Time Slot column header first
    /* loop through the node names, adding each to the header */
    for (int i = 0; i < orderedNodes.length; i++) {
      columnNames[i + 1] = orderedNodes[i];
    }
    return columnNames;
  }
  
  /**
   * Builds the visualization data matrix that represents the program schedule.
   * Each row corresponds to a time slot, and each column corresponds to a node.
   * The entries indicate the transmission or operation performed by the node
   * in that time slot.
   * 
   * @return a 2D string array representing the schedule visualization data
   */
>>>>>>> branch 'HW5' of https://research-git.uiowa.edu/smukunza/cs2820-smukunza

			for (int row = 0; row < numRows; row++) {
				visualizationData[row][0] = String.format("%s", row);
				for (int column = 0; column < numColumns; column++) {
					visualizationData[row][column + 1] = sourceCode.get(row, column);
				}
			}
		}
		return visualizationData;
	}

<<<<<<< HEAD
	/**
	 * Creates the visualization title string.
	 * 
	 * @return a title string containing the program name 
	 */
	private String createTitle() {
		return String.format("WARP program for graph %s\n", program.getName());
	}
=======
      for (int row = 0; row < numRows; row++) {
        visualizationData[row][0] = String.format("%s", row);
        for (int column = 0; column < numColumns; column++) {
          visualizationData[row][column + 1] = sourceCode.get(row, column);
        }
      }
    }
    return visualizationData;
  }
  
  /**
   * Creates the title string used in both the header and the visualization window.
   * The title includes the program name.
   * 
   * @return a formatted string with the program title
   */

  private String createTitle() {
    return String.format("WARP program for graph %s\n", program.getName());
  }
>>>>>>> branch 'HW5' of https://research-git.uiowa.edu/smukunza/cs2820-smukunza
}
